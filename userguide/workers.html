<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Workers Guide &mdash; Celery 3.1.0a1 documentation</title>
    
    <link rel="stylesheet" href="../_static/celery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/issuetracker.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.1.0a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Celery 3.1.0a1 documentation" href="../index.html" />
    <link rel="up" title="User Guide" href="index.html" />
    <link rel="next" title="Periodic Tasks" href="periodic-tasks.html" />
    <link rel="prev" title="Canvas: Designing Workflows" href="canvas.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="periodic-tasks.html" title="Periodic Tasks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="canvas.html" title="Canvas: Designing Workflows"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Celery 3.1.0a1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">User Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
<div class="deck">

    
        <p class="developmentversion">
        This document is for Celery's development version, which can be
        significantly different from previous releases. Get old docs here:

        <a href="http://docs.celeryproject.org/en/latest/userguide/workers.html">3.0</a>.
        </p>
        

</div>
    <div class="section" id="workers-guide">
<span id="guide-workers"></span><h1>Workers Guide<a class="headerlink" href="#workers-guide" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#starting-the-worker" id="id1">Starting the worker</a></li>
<li><a class="reference internal" href="#stopping-the-worker" id="id2">Stopping the worker</a></li>
<li><a class="reference internal" href="#restarting-the-worker" id="id3">Restarting the worker</a></li>
<li><a class="reference internal" href="#process-signals" id="id4">Process Signals</a></li>
<li><a class="reference internal" href="#concurrency" id="id5">Concurrency</a></li>
<li><a class="reference internal" href="#remote-control" id="id6">Remote control</a></li>
<li><a class="reference internal" href="#revoking-tasks" id="id7">Revoking tasks</a></li>
<li><a class="reference internal" href="#time-limits" id="id8">Time Limits</a></li>
<li><a class="reference internal" href="#rate-limits" id="id9">Rate Limits</a></li>
<li><a class="reference internal" href="#max-tasks-per-child-setting" id="id10">Max tasks per child setting</a></li>
<li><a class="reference internal" href="#autoscaling" id="id11">Autoscaling</a></li>
<li><a class="reference internal" href="#queues" id="id12">Queues</a></li>
<li><a class="reference internal" href="#autoreloading" id="id13">Autoreloading</a></li>
<li><a class="reference internal" href="#inspecting-workers" id="id14">Inspecting workers</a></li>
<li><a class="reference internal" href="#additional-commands" id="id15">Additional Commands</a></li>
<li><a class="reference internal" href="#writing-your-own-remote-control-commands" id="id16">Writing your own remote control commands</a></li>
</ul>
</div>
<div class="section" id="starting-the-worker">
<span id="worker-starting"></span><h2><a class="toc-backref" href="#id1">Starting the worker</a><a class="headerlink" href="#starting-the-worker" title="Permalink to this headline">¶</a></h2>
<div class="sidebar">
<p class="first sidebar-title">Daemonizing</p>
<p class="last">You probably want to use a daemonization tool to start
in the background.  See <a class="reference internal" href="../tutorials/daemonizing.html#daemonizing"><em>Running the worker as a daemon</em></a> for help
detaching the worker using popular daemonization tools.</p>
</div>
<p>You can start the worker in the foreground by executing the command:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery worker --app<span class="o">=</span>app -l info
</pre></div>
</div>
<p>For a full list of available command line options see
<a class="reference internal" href="../reference/celery.bin.celeryd.html#module-celery.bin.celeryd" title="celery.bin.celeryd"><tt class="xref py py-mod docutils literal"><span class="pre">celeryd</span></tt></a>, or simply do:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery worker --help
</pre></div>
</div>
<p>You can also start multiple workers on the same machine. If you do so
be sure to give a unique name to each individual worker by specifying a
host name with the <em class="xref std std-option">--hostname|-n</em> argument:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery worker --loglevel<span class="o">=</span>INFO --concurrency<span class="o">=</span>10 -n worker1.%h
<span class="nv">$ </span>celery worker --loglevel<span class="o">=</span>INFO --concurrency<span class="o">=</span>10 -n worker2.%h
<span class="nv">$ </span>celery worker --loglevel<span class="o">=</span>INFO --concurrency<span class="o">=</span>10 -n worker3.%h
</pre></div>
</div>
<p>The hostname argument can expand the following variables:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">%h</span></tt>:  Hostname including domain name.</li>
<li><tt class="docutils literal"><span class="pre">%n</span></tt>:  Hostname only.</li>
<li><tt class="docutils literal"><span class="pre">%d</span></tt>:  Domain name only.</li>
</ul>
</div></blockquote>
<p>E.g. if the current hostname is <tt class="docutils literal"><span class="pre">george.example.com</span></tt> then
these will expand to:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">worker1.%h</span></tt> -&gt; <tt class="docutils literal"><span class="pre">worker1.george.example.com</span></tt></li>
<li><tt class="docutils literal"><span class="pre">worker1.%n</span></tt> -&gt; <tt class="docutils literal"><span class="pre">worker1.george</span></tt></li>
<li><tt class="docutils literal"><span class="pre">worker1.%d</span></tt> -&gt; <tt class="docutils literal"><span class="pre">worker1.example.com</span></tt></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="stopping-the-worker">
<span id="worker-stopping"></span><h2><a class="toc-backref" href="#id2">Stopping the worker</a><a class="headerlink" href="#stopping-the-worker" title="Permalink to this headline">¶</a></h2>
<p>Shutdown should be accomplished using the <tt class="xref std std-sig docutils literal"><span class="pre">TERM</span></tt> signal.</p>
<p>When shutdown is initiated the worker will finish all currently executing
tasks before it actually terminates, so if these tasks are important you should
wait for it to finish before doing anything drastic (like sending the <tt class="xref std std-sig docutils literal"><span class="pre">KILL</span></tt>
signal).</p>
<p>If the worker won&#8217;t shutdown after considerate time, for example because
of tasks stuck in an infinite-loop, you can use the <tt class="xref std std-sig docutils literal"><span class="pre">KILL</span></tt> signal to
force terminate the worker, but be aware that currently executing tasks will
be lost (unless the tasks have the <a class="reference internal" href="../reference/celery.app.task.html#celery.app.task.Task.acks_late" title="celery.app.task.Task.acks_late"><tt class="xref py py-attr docutils literal"><span class="pre">acks_late</span></tt></a>
option set).</p>
<p>Also as processes can&#8217;t override the <tt class="xref std std-sig docutils literal"><span class="pre">KILL</span></tt> signal, the worker will
not be able to reap its children, so make sure to do so manually.  This
command usually does the trick:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>ps auxww | grep <span class="s1">&#39;celery worker&#39;</span> | awk <span class="s1">&#39;{print $2}&#39;</span> | xargs <span class="nb">kill</span> -9
</pre></div>
</div>
</div>
<div class="section" id="restarting-the-worker">
<span id="worker-restarting"></span><h2><a class="toc-backref" href="#id3">Restarting the worker</a><a class="headerlink" href="#restarting-the-worker" title="Permalink to this headline">¶</a></h2>
<p>Other than stopping then starting the worker to restart, you can also
restart the worker using the <tt class="xref std std-sig docutils literal"><span class="pre">HUP</span></tt> signal:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">kill</span> -HUP <span class="nv">$pid</span>
</pre></div>
</div>
<p>The worker will then replace itself with a new instance using the same
arguments as it was started with.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Restarting by <tt class="xref std std-sig docutils literal"><span class="pre">HUP</span></tt> only works if the worker is running
in the background as a daemon (it does not have a controlling
terminal).</p>
<p class="last"><tt class="xref std std-sig docutils literal"><span class="pre">HUP</span></tt> is disabled on OS X because of a limitation on
that platform.</p>
</div>
</div>
<div class="section" id="process-signals">
<span id="worker-process-signals"></span><h2><a class="toc-backref" href="#id4">Process Signals</a><a class="headerlink" href="#process-signals" title="Permalink to this headline">¶</a></h2>
<p>The worker&#8217;s main process overrides the following signals:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref std std-sig docutils literal"><span class="pre">TERM</span></tt></td>
<td>Warm shutdown, wait for tasks to complete.</td>
</tr>
<tr class="row-even"><td><tt class="xref std std-sig docutils literal"><span class="pre">QUIT</span></tt></td>
<td>Cold shutdown, terminate ASAP</td>
</tr>
<tr class="row-odd"><td><tt class="xref std std-sig docutils literal"><span class="pre">USR1</span></tt></td>
<td>Dump traceback for all active threads.</td>
</tr>
<tr class="row-even"><td><tt class="xref std std-sig docutils literal"><span class="pre">USR2</span></tt></td>
<td>Remote debug, see <a class="reference internal" href="../reference/celery.contrib.rdb.html#module-celery.contrib.rdb" title="celery.contrib.rdb"><tt class="xref py py-mod docutils literal"><span class="pre">celery.contrib.rdb</span></tt></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="concurrency">
<span id="worker-concurrency"></span><h2><a class="toc-backref" href="#id5">Concurrency</a><a class="headerlink" href="#concurrency" title="Permalink to this headline">¶</a></h2>
<p>By default multiprocessing is used to perform concurrent execution of tasks,
but you can also use <a class="reference internal" href="concurrency/eventlet.html#concurrency-eventlet"><em>Eventlet</em></a>.  The number
of worker processes/threads can be changed using the <em class="xref std std-option">--concurrency</em>
argument and defaults to the number of CPUs available on the machine.</p>
<div class="admonition-number-of-processes-multiprocessing admonition">
<p class="first admonition-title">Number of processes (multiprocessing)</p>
<p class="last">More pool processes are usually better, but there&#8217;s a cut-off point where
adding more pool processes affects performance in negative ways.
There is even some evidence to support that having multiple worker
instances running, may perform better than having a single worker.
For example 3 workers with 10 pool processes each.  You need to experiment
to find the numbers that works best for you, as this varies based on
application, work load, task run times and other factors.</p>
</div>
</div>
<div class="section" id="remote-control">
<span id="worker-remote-control"></span><h2><a class="toc-backref" href="#id6">Remote control</a><a class="headerlink" href="#remote-control" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.0.</span></p>
<div class="sidebar">
<p class="first sidebar-title">The <tt class="docutils literal"><span class="pre">celery</span></tt> command</p>
<p class="last">The <strong class="program">celery</strong> program is used to execute remote control
commands from the command line.  It supports all of the commands
listed below.  See <a class="reference internal" href="monitoring.html#monitoring-celeryctl"><em>celery: Management Command-line Utilities</em></a> for more information.</p>
</div>
<p>pool support: <em>processes, eventlet, gevent</em>, blocking:<em>threads/solo</em> (see note)
broker support: <em>amqp, redis, mongodb</em></p>
<p>Workers have the ability to be remote controlled using a high-priority
broadcast message queue.  The commands can be directed to all, or a specific
list of workers.</p>
<p>Commands can also have replies.  The client can then wait for and collect
those replies.  Since there&#8217;s no central authority to know how many
workers are available in the cluster, there is also no way to estimate
how many workers may send a reply, so the client has a configurable
timeout — the deadline in seconds for replies to arrive in.  This timeout
defaults to one second.  If the worker doesn&#8217;t reply within the deadline
it doesn&#8217;t necessarily mean the worker didn&#8217;t reply, or worse is dead, but
may simply be caused by network latency or the worker being slow at processing
commands, so adjust the timeout accordingly.</p>
<p>In addition to timeouts, the client can specify the maximum number
of replies to wait for.  If a destination is specified, this limit is set
to the number of destination hosts.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The solo and threads pool supports remote control commands,
but any task executing will block any waiting control command,
so it is of limited use if the worker is very busy.  In that
case you must increase the timeout waiting for replies in the client.</p>
</div>
<div class="section" id="the-broadcast-function">
<span id="worker-broadcast-fun"></span><h3>The <a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.broadcast" title="celery.app.control.Control.broadcast"><tt class="xref py py-meth docutils literal"><span class="pre">broadcast()</span></tt></a> function.<a class="headerlink" href="#the-broadcast-function" title="Permalink to this headline">¶</a></h3>
<p>This is the client function used to send commands to the workers.
Some remote control commands also have higher-level interfaces using
<a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.broadcast" title="celery.app.control.Control.broadcast"><tt class="xref py py-meth docutils literal"><span class="pre">broadcast()</span></tt></a> in the background, like
<a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.rate_limit" title="celery.app.control.Control.rate_limit"><tt class="xref py py-meth docutils literal"><span class="pre">rate_limit()</span></tt></a> and <a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.ping" title="celery.app.control.Control.ping"><tt class="xref py py-meth docutils literal"><span class="pre">ping()</span></tt></a>.</p>
<p>Sending the <a class="reference internal" href="#std:control-rate_limit"><tt class="xref std std-control docutils literal"><span class="pre">rate_limit</span></tt></a> command and keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;rate_limit&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;task_name&#39;</span><span class="p">:</span> <span class="s">&#39;myapp.mytask&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s">&#39;rate_limit&#39;</span><span class="p">:</span> <span class="s">&#39;200/m&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>This will send the command asynchronously, without waiting for a reply.
To request a reply you have to use the <cite>reply</cite> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;rate_limit&#39;</span><span class="p">,</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s">&#39;task_name&#39;</span><span class="p">:</span> <span class="s">&#39;myapp.mytask&#39;</span><span class="p">,</span> <span class="s">&#39;rate_limit&#39;</span><span class="p">:</span> <span class="s">&#39;200/m&#39;</span><span class="p">},</span> <span class="n">reply</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[{&#39;worker1.example.com&#39;: &#39;New rate limit set successfully&#39;},</span>
<span class="go"> {&#39;worker2.example.com&#39;: &#39;New rate limit set successfully&#39;},</span>
<span class="go"> {&#39;worker3.example.com&#39;: &#39;New rate limit set successfully&#39;}]</span>
</pre></div>
</div>
<p>Using the <cite>destination</cite> argument you can specify a list of workers
to receive the command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;rate_limit&#39;</span><span class="p">,</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s">&#39;task_name&#39;</span><span class="p">:</span> <span class="s">&#39;myapp.mytask&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&#39;rate_limit&#39;</span><span class="p">:</span> <span class="s">&#39;200/m&#39;</span><span class="p">},</span> <span class="n">reply</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">destination</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;worker1.example.com&#39;</span><span class="p">])</span>
<span class="go">[{&#39;worker1.example.com&#39;: &#39;New rate limit set successfully&#39;}]</span>
</pre></div>
</div>
<p>Of course, using the higher-level interface to set rate limits is much
more convenient, but there are commands that can only be requested
using <a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.broadcast" title="celery.app.control.Control.broadcast"><tt class="xref py py-meth docutils literal"><span class="pre">broadcast()</span></tt></a>.</p>
</div>
</div>
<div class="section" id="revoking-tasks">
<span id="std:control-revoke"></span><h2><a class="toc-backref" href="#id7">Revoking tasks</a><a class="headerlink" href="#revoking-tasks" title="Permalink to this headline">¶</a></h2>
<p>pool support: all
broker support: <em>amqp, redis, mongodb</em></p>
<p>All worker nodes keeps a memory of revoked task ids, either in-memory or
persistent on disk (see <a class="reference internal" href="#worker-persistent-revokes"><em>Persistent revokes</em></a>).</p>
<p>When a worker receives a revoke request it will skip executing
the task, but it won&#8217;t terminate an already executing task unless
the <cite>terminate</cite> option is set.</p>
<p>If <cite>terminate</cite> is set the worker child process processing the task
will be terminated.  The default signal sent is <cite>TERM</cite>, but you can
specify this using the <cite>signal</cite> argument.  Signal can be the uppercase name
of any signal defined in the <a class="reference external" href="http://docs.python.org/dev/library/signal.html#signal" title="(in Python v3.3)"><tt class="xref py py-mod docutils literal"><span class="pre">signal</span></tt></a> module in the Python Standard
Library.</p>
<p>Terminating a task also revokes it.</p>
<p><strong>Example</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="s">&#39;d9078da5-9915-40a0-bfa1-392c7bde42ed&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="s">&#39;d9078da5-9915-40a0-bfa1-392c7bde42ed&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">terminate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="s">&#39;d9078da5-9915-40a0-bfa1-392c7bde42ed&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">terminate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s">&#39;SIGKILL&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="persistent-revokes">
<span id="worker-persistent-revokes"></span><h3>Persistent revokes<a class="headerlink" href="#persistent-revokes" title="Permalink to this headline">¶</a></h3>
<p>Revoking tasks works by sending a broadcast message to all the workers,
the workers then keep a list of revoked tasks in memory.</p>
<p>If you want tasks to remain revoked after worker restart you need to
specify a file for these to be stored in, either by using the <cite>&#8211;statedb</cite>
argument to <strong class="program">celery worker</strong> or the <a class="reference internal" href="../configuration.html#std:setting-CELERYD_STATE_DB"><tt class="xref std std-setting docutils literal"><span class="pre">CELERYD_STATE_DB</span></tt></a>
setting.</p>
<p>Note that remote control commands must be working for revokes to work.
Remote control commands are only supported by the RabbitMQ (amqp), Redis and MongDB
transports at this point.</p>
</div>
</div>
<div class="section" id="time-limits">
<span id="worker-time-limits"></span><h2><a class="toc-backref" href="#id8">Time Limits</a><a class="headerlink" href="#time-limits" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.0.</span></p>
<p>pool support: <em>processes</em></p>
<div class="sidebar">
<p class="first sidebar-title">Soft, or hard?</p>
<p class="last">The time limit is set in two values, <cite>soft</cite> and <cite>hard</cite>.
The soft time limit allows the task to catch an exception
to clean up before it is killed: the hard timeout is not catchable
and force terminates the task.</p>
</div>
<p>A single task can potentially run forever, if you have lots of tasks
waiting for some event that will never happen you will block the worker
from processing new tasks indefinitely.  The best way to defend against
this scenario happening is enabling time limits.</p>
<p>The time limit (<cite>&#8211;time-limit</cite>) is the maximum number of seconds a task
may run before the process executing it is terminated and replaced by a
new process.  You can also enable a soft time limit (<cite>&#8211;soft-time-limit</cite>),
this raises an exception the task can catch to clean up before the hard
time limit kills it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myapp</span> <span class="kn">import</span> <span class="n">celery</span>
<span class="kn">from</span> <span class="nn">celery.exceptions</span> <span class="kn">import</span> <span class="n">SoftTimeLimitExceeded</span>

<span class="nd">@celery.task</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">do_work</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">SoftTimeLimitExceeded</span><span class="p">:</span>
        <span class="n">clean_up_in_a_hurry</span><span class="p">()</span>
</pre></div>
</div>
<p>Time limits can also be set using the <a class="reference internal" href="../configuration.html#std:setting-CELERYD_TASK_TIME_LIMIT"><tt class="xref std std-setting docutils literal"><span class="pre">CELERYD_TASK_TIME_LIMIT</span></tt></a> /
<tt class="xref std std-setting docutils literal"><span class="pre">CELERYD_SOFT_TASK_TIME_LIMIT</span></tt> settings.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Time limits do not currently work on Windows and other
platforms that do not support the <tt class="docutils literal"><span class="pre">SIGUSR1</span></tt> signal.</p>
</div>
<div class="section" id="changing-time-limits-at-runtime">
<h3>Changing time limits at runtime<a class="headerlink" href="#changing-time-limits-at-runtime" title="Permalink to this headline">¶</a></h3>
<p class="versionadded">
<span class="versionmodified">New in version 2.3.</span></p>
<p>broker support: <em>amqp, redis, mongodb</em></p>
<p>There is a remote control command that enables you to change both soft
and hard time limits for a task — named <tt class="docutils literal"><span class="pre">time_limit</span></tt>.</p>
<p>Example changing the time limit for the <tt class="docutils literal"><span class="pre">tasks.crawl_the_web</span></tt> task
to have a soft time limit of one minute, and a hard time limit of
two minutes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">time_limit</span><span class="p">(</span><span class="s">&#39;tasks.crawl_the_web&#39;</span><span class="p">,</span>
<span class="go">                              soft=60, hard=120, reply=True)</span>
<span class="go">[{&#39;worker1.example.com&#39;: {&#39;ok&#39;: &#39;time limits set successfully&#39;}}]</span>
</pre></div>
</div>
<p>Only tasks that starts executing after the time limit change will be affected.</p>
</div>
</div>
<div class="section" id="rate-limits">
<span id="worker-rate-limits"></span><h2><a class="toc-backref" href="#id9">Rate Limits</a><a class="headerlink" href="#rate-limits" title="Permalink to this headline">¶</a></h2>
<div class="section" id="changing-rate-limits-at-runtime">
<span id="std:control-rate_limit"></span><h3>Changing rate-limits at runtime<a class="headerlink" href="#changing-rate-limits-at-runtime" title="Permalink to this headline">¶</a></h3>
<p>Example changing the rate limit for the <cite>myapp.mytask</cite> task to accept
200 tasks a minute on all servers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">rate_limit</span><span class="p">(</span><span class="s">&#39;myapp.mytask&#39;</span><span class="p">,</span> <span class="s">&#39;200/m&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example changing the rate limit on a single host by specifying the
destination host name:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">rate_limit</span><span class="p">(</span><span class="s">&#39;myapp.mytask&#39;</span><span class="p">,</span> <span class="s">&#39;200/m&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">destination</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;worker1.example.com&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This won&#8217;t affect workers with the
<a class="reference internal" href="../configuration.html#std:setting-CELERY_DISABLE_RATE_LIMITS"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_DISABLE_RATE_LIMITS</span></tt></a> setting enabled.</p>
</div>
</div>
</div>
<div class="section" id="max-tasks-per-child-setting">
<span id="worker-maxtasksperchild"></span><h2><a class="toc-backref" href="#id10">Max tasks per child setting</a><a class="headerlink" href="#max-tasks-per-child-setting" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.0.</span></p>
<p>pool support: <em>processes</em></p>
<p>With this option you can configure the maximum number of tasks
a worker can execute before it&#8217;s replaced by a new process.</p>
<p>This is useful if you have memory leaks you have no control over
for example from closed source C extensions.</p>
<p>The option can be set using the workers <cite>&#8211;maxtasksperchild</cite> argument
or using the <a class="reference internal" href="../configuration.html#std:setting-CELERYD_MAX_TASKS_PER_CHILD"><tt class="xref std std-setting docutils literal"><span class="pre">CELERYD_MAX_TASKS_PER_CHILD</span></tt></a> setting.</p>
</div>
<div class="section" id="autoscaling">
<span id="worker-autoscaling"></span><h2><a class="toc-backref" href="#id11">Autoscaling</a><a class="headerlink" href="#autoscaling" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.2.</span></p>
<p>pool support: <em>processes</em>, <em>gevent</em></p>
<p>The <em>autoscaler</em> component is used to dynamically resize the pool
based on load:</p>
<ul>
<li><dl class="first docutils">
<dt>The autoscaler adds more pool processes when there is work to do,</dt>
<dd><ul class="first last simple">
<li>and starts removing processes when the workload is low.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>It&#8217;s enabled by the <em class="xref std std-option">--autoscale</em> option, which needs two
numbers: the maximum and minimum number of pool processes:</p>
<div class="highlight-python"><pre>--autoscale=AUTOSCALE
     Enable autoscaling by providing
     max_concurrency,min_concurrency.  Example:
       --autoscale=10,3 (always keep 3 processes, but grow to
      10 if necessary).</pre>
</div>
<p>You can also define your own rules for the autoscaler by subclassing
<tt class="xref py py-class docutils literal"><span class="pre">Autoscaler</span></tt>.
Some ideas for metrics include load average or the amount of memory available.
You can specify a custom autoscaler with the <a class="reference internal" href="../configuration.html#std:setting-CELERYD_AUTOSCALER"><tt class="xref std std-setting docutils literal"><span class="pre">CELERYD_AUTOSCALER</span></tt></a> setting.</p>
</div>
<div class="section" id="queues">
<span id="worker-queues"></span><h2><a class="toc-backref" href="#id12">Queues</a><a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h2>
<p>A worker instance can consume from any number of queues.
By default it will consume from all queues defined in the
<a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a> setting (which if not specified defaults to the
queue named <tt class="docutils literal"><span class="pre">celery</span></tt>).</p>
<p>You can specify what queues to consume from at startup,
by giving a comma separated list of queues to the <em class="xref std std-option">-Q</em> option:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery worker -l info -Q foo,bar,baz
</pre></div>
</div>
<p>If the queue name is defined in <a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a> it will use that
configuration, but if it&#8217;s not defined in the list of queues Celery will
automatically generate a new queue for you (depending on the
<a class="reference internal" href="../configuration.html#std:setting-CELERY_CREATE_MISSING_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_CREATE_MISSING_QUEUES</span></tt></a> option).</p>
<p>You can also tell the worker to start and stop consuming from a queue at
runtime using the remote control commands <a class="reference internal" href="#std:control-add_consumer"><tt class="xref std std-control docutils literal"><span class="pre">add_consumer</span></tt></a> and
<a class="reference internal" href="#std:control-cancel_consumer"><tt class="xref std std-control docutils literal"><span class="pre">cancel_consumer</span></tt></a>.</p>
<div class="section" id="queues-adding-consumers">
<span id="std:control-add_consumer"></span><h3>Queues: Adding consumers<a class="headerlink" href="#queues-adding-consumers" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#std:control-add_consumer"><tt class="xref std std-control docutils literal"><span class="pre">add_consumer</span></tt></a> control command will tell one or more workers
to start consuming from a queue. This operation is idempotent.</p>
<p>To tell all workers in the cluster to start consuming from a queue
named &#8220;<tt class="docutils literal"><span class="pre">foo</span></tt>&#8221; you can use the <strong class="program">celery control</strong> program:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery control add_consumer foo
-&gt; worker1.local: OK
    started consuming from u<span class="s1">&#39;foo&#39;</span>
</pre></div>
</div>
<p>If you want to specify a specific worker you can use the
<em class="xref std std-option">--destination`</em> argument:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery control add_consumer foo -d worker1.local
</pre></div>
</div>
<p>The same can be accomplished dynamically using the <a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.add_consumer" title="celery.app.control.Control.add_consumer"><tt class="xref py py-meth docutils literal"><span class="pre">celery.control.add_consumer()</span></tt></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myapp</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">add_consumer</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="n">reply</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[{u&#39;worker1.local&#39;: {u&#39;ok&#39;: u&quot;already consuming from u&#39;foo&#39;&quot;}}]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">myapp</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">add_consumer</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="n">reply</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">destination</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;worker1.local&#39;</span><span class="p">])</span>
<span class="go">[{u&#39;worker1.local&#39;: {u&#39;ok&#39;: u&quot;already consuming from u&#39;foo&#39;&quot;}}]</span>
</pre></div>
</div>
<p>By now I have only shown examples using automatic queues,
If you need more control you can also specify the exchange, routing_key and
even other options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myapp</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">add_consumer</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">queue</span><span class="o">=</span><span class="s">&#39;baz&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">exchange</span><span class="o">=</span><span class="s">&#39;ex&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">exchange_type</span><span class="o">=</span><span class="s">&#39;topic&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;media.*&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">options</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s">&#39;queue_durable&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s">&#39;exchange_durable&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span>    <span class="n">reply</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">destination</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;worker1.local&#39;</span><span class="p">,</span> <span class="s">&#39;worker2.local&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="queues-cancelling-consumers">
<span id="std:control-cancel_consumer"></span><h3>Queues: Cancelling consumers<a class="headerlink" href="#queues-cancelling-consumers" title="Permalink to this headline">¶</a></h3>
<p>You can cancel a consumer by queue name using the <a class="reference internal" href="#std:control-cancel_consumer"><tt class="xref std std-control docutils literal"><span class="pre">cancel_consumer</span></tt></a>
control command.</p>
<p>To force all workers in the cluster to cancel consuming from a queue
you can use the <strong class="program">celery control</strong> program:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery control cancel_consumer foo
</pre></div>
</div>
<p>The <em class="xref std std-option">--destination</em> argument can be used to specify a worker, or a
list of workers, to act on the command:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery control cancel_consumer foo -d worker1.local
</pre></div>
</div>
<p>You can also cancel consumers programmatically using the
<a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.cancel_consumer" title="celery.app.control.Control.cancel_consumer"><tt class="xref py py-meth docutils literal"><span class="pre">celery.control.cancel_consumer()</span></tt></a> method:</p>
<div class="highlight-bash"><div class="highlight"><pre>&gt;&gt;&gt; myapp.control.cancel_consumer<span class="o">(</span><span class="s1">&#39;foo&#39;</span>, <span class="nv">reply</span><span class="o">=</span>True<span class="o">)</span>
<span class="o">[{</span>u<span class="s1">&#39;worker1.local&#39;</span>: <span class="o">{</span>u<span class="s1">&#39;ok&#39;</span>: u<span class="s2">&quot;no longer consuming from u&#39;foo&#39;&quot;</span><span class="o">}}]</span>
</pre></div>
</div>
</div>
<div class="section" id="queues-list-of-active-queues">
<span id="std:control-active_queues"></span><h3>Queues: List of active queues<a class="headerlink" href="#queues-list-of-active-queues" title="Permalink to this headline">¶</a></h3>
<p>You can get a list of queues that a worker consumes from by using
the <a class="reference internal" href="#std:control-active_queues"><tt class="xref std std-control docutils literal"><span class="pre">active_queues</span></tt></a> control command:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery inspect active_queues
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>Like all other remote control commands this also supports the
<em class="xref std std-option">--destination</em> argument used to specify which workers should
reply to the request:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery inspect active_queues -d worker1.local
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>This can also be done programmatically by using the
<tt class="xref py py-meth docutils literal"><span class="pre">celery.control.inspect.active_queues()</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myapp</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span><span class="o">.</span><span class="n">active_queues</span><span class="p">()</span>
<span class="go">[...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">myapp</span><span class="o">.</span><span class="n">inspect</span><span class="p">([</span><span class="s">&#39;worker1.local&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">active_queues</span><span class="p">()</span>
<span class="go">[...]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="autoreloading">
<span id="worker-autoreloading"></span><h2><a class="toc-backref" href="#id13">Autoreloading</a><a class="headerlink" href="#autoreloading" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.5.</span></p>
<p>pool support: <em>processes, eventlet, gevent, threads, solo</em></p>
<p>Starting <strong class="program">celery worker</strong> with the <em class="xref std std-option">--autoreload</em> option will
enable the worker to watch for file system changes to all imported task
modules imported (and also any non-task modules added to the
<a class="reference internal" href="../configuration.html#std:setting-CELERY_IMPORTS"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_IMPORTS</span></tt></a> setting or the <em class="xref std std-option">-I|--include</em> option).</p>
<p>This is an experimental feature intended for use in development only,
using auto-reload in production is discouraged as the behavior of reloading
a module in Python is undefined, and may cause hard to diagnose bugs and
crashes.  Celery uses the same approach as the auto-reloader found in e.g.
the Django <tt class="docutils literal"><span class="pre">runserver</span></tt> command.</p>
<p>When auto-reload is enabled the worker starts an additional thread
that watches for changes in the file system.  New modules are imported,
and already imported modules are reloaded whenever a change is detected,
and if the processes pool is used the child processes will finish the work
they are doing and exit, so that they can be replaced by fresh processes
effectively reloading the code.</p>
<p>File system notification backends are pluggable, and it comes with three
implementations:</p>
<ul>
<li><p class="first">inotify (Linux)</p>
<blockquote>
<div><p>Used if the <tt class="xref py py-mod docutils literal"><span class="pre">pyinotify</span></tt> library is installed.
If you are running on Linux this is the recommended implementation,
to install the <tt class="xref py py-mod docutils literal"><span class="pre">pyinotify</span></tt> library you have to run the following
command:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>pip install pyinotify
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">kqueue (OS X/BSD)</p>
</li>
<li><p class="first">stat</p>
<blockquote>
<div><p>The fallback implementation simply polls the files using <tt class="docutils literal"><span class="pre">stat</span></tt> and is very
expensive.</p>
</div></blockquote>
</li>
</ul>
<p>You can force an implementation by setting the <span class="target" id="index-0"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CELERYD_FSNOTIFY</span></tt>
environment variable:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>env <span class="nv">CELERYD_FSNOTIFY</span><span class="o">=</span>stat celery worker -l info --autoreload
</pre></div>
</div>
<span class="target" id="worker-autoreload"></span><div class="section" id="pool-restart-command">
<span id="std:control-pool_restart"></span><h3>Pool Restart Command<a class="headerlink" href="#pool-restart-command" title="Permalink to this headline">¶</a></h3>
<p class="versionadded">
<span class="versionmodified">New in version 2.5.</span></p>
<p>Requires the <a class="reference internal" href="../configuration.html#std:setting-CELERYD_POOL_RESTARTS"><tt class="xref std std-setting docutils literal"><span class="pre">CELERYD_POOL_RESTARTS</span></tt></a> setting to be enabled.</p>
<p>The remote control command <a class="reference internal" href="#std:control-pool_restart"><tt class="xref std std-control docutils literal"><span class="pre">pool_restart</span></tt></a> sends restart requests to
the workers child processes.  It is particularly useful for forcing
the worker to import new modules, or for reloading already imported
modules.  This command does not interrupt executing tasks.</p>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>Running the following command will result in the <cite>foo</cite> and <cite>bar</cite> modules
being imported by the worker processes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;pool_restart&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;modules&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<p>Use the <tt class="docutils literal"><span class="pre">reload</span></tt> argument to reload modules it has already imported:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;pool_restart&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;modules&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                    <span class="s">&#39;reload&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>If you don&#8217;t specify any modules then all known tasks modules will
be imported/reloaded:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;pool_restart&#39;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;reload&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">modules</span></tt> argument is a list of modules to modify. <tt class="docutils literal"><span class="pre">reload</span></tt>
specifies whether to reload modules if they have previously been imported.
By default <tt class="docutils literal"><span class="pre">reload</span></tt> is disabled. The <cite>pool_restart</cite> command uses the
Python <tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt> function to reload modules, or you can provide
your own custom reloader by passing the <tt class="docutils literal"><span class="pre">reloader</span></tt> argument.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Module reloading comes with caveats that are documented in <tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt>.
Please read this documentation and make sure your modules are suitable
for reloading.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="http://pyunit.sourceforge.net/notes/reloading.html">http://pyunit.sourceforge.net/notes/reloading.html</a></li>
<li><a class="reference external" href="http://www.indelible.org/ink/python-reloading/">http://www.indelible.org/ink/python-reloading/</a></li>
<li><a class="reference external" href="http://docs.python.org/library/functions.html#reload">http://docs.python.org/library/functions.html#reload</a></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="inspecting-workers">
<span id="worker-inspect"></span><h2><a class="toc-backref" href="#id14">Inspecting workers</a><a class="headerlink" href="#inspecting-workers" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.inspect" title="celery.app.control.Control.inspect"><tt class="xref py py-class docutils literal"><span class="pre">celery.control.inspect</span></tt></a> lets you inspect running workers.  It
uses remote control commands under the hood.</p>
<p>You can also use the <tt class="docutils literal"><span class="pre">celery</span></tt> command to inspect workers,
and it supports the same commands as the <a class="reference internal" href="../reference/celery.html#celery.Celery.control" title="celery.Celery.control"><tt class="xref py py-class docutils literal"><span class="pre">Celery.control</span></tt></a> interface.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Inspect all nodes.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>

<span class="c"># Specify multiple nodes to inspect.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">inspect</span><span class="p">([</span><span class="s">&#39;worker1.example.com&#39;</span><span class="p">,</span>
                                <span class="s">&#39;worker2.example.com&#39;</span><span class="p">])</span>

<span class="c"># Specify a single node to inspect.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="s">&#39;worker1.example.com&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="dump-of-registered-tasks">
<span id="worker-inspect-registered-tasks"></span><h3>Dump of registered tasks<a class="headerlink" href="#dump-of-registered-tasks" title="Permalink to this headline">¶</a></h3>
<p>You can get a list of tasks registered in the worker using the
<tt class="xref py py-meth docutils literal"><span class="pre">registered()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">registered</span><span class="p">()</span>
<span class="go">[{&#39;worker1.example.com&#39;: [&#39;tasks.add&#39;,</span>
<span class="go">                          &#39;tasks.sleeptask&#39;]}]</span>
</pre></div>
</div>
</div>
<div class="section" id="dump-of-currently-executing-tasks">
<span id="worker-inspect-active-tasks"></span><h3>Dump of currently executing tasks<a class="headerlink" href="#dump-of-currently-executing-tasks" title="Permalink to this headline">¶</a></h3>
<p>You can get a list of active tasks using
<tt class="xref py py-meth docutils literal"><span class="pre">active()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">active</span><span class="p">()</span>
<span class="go">[{&#39;worker1.example.com&#39;:</span>
<span class="go">    [{&#39;name&#39;: &#39;tasks.sleeptask&#39;,</span>
<span class="go">      &#39;id&#39;: &#39;32666e9b-809c-41fa-8e93-5ae0c80afbbf&#39;,</span>
<span class="go">      &#39;args&#39;: &#39;(8,)&#39;,</span>
<span class="go">      &#39;kwargs&#39;: &#39;{}&#39;}]}]</span>
</pre></div>
</div>
</div>
<div class="section" id="dump-of-scheduled-eta-tasks">
<span id="worker-inspect-eta-schedule"></span><h3>Dump of scheduled (ETA) tasks<a class="headerlink" href="#dump-of-scheduled-eta-tasks" title="Permalink to this headline">¶</a></h3>
<p>You can get a list of tasks waiting to be scheduled by using
<tt class="xref py py-meth docutils literal"><span class="pre">scheduled()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">scheduled</span><span class="p">()</span>
<span class="go">[{&#39;worker1.example.com&#39;:</span>
<span class="go">    [{&#39;eta&#39;: &#39;2010-06-07 09:07:52&#39;, &#39;priority&#39;: 0,</span>
<span class="go">      &#39;request&#39;: {</span>
<span class="go">        &#39;name&#39;: &#39;tasks.sleeptask&#39;,</span>
<span class="go">        &#39;id&#39;: &#39;1a7980ea-8b19-413e-91d2-0b74f3844c4d&#39;,</span>
<span class="go">        &#39;args&#39;: &#39;[1]&#39;,</span>
<span class="go">        &#39;kwargs&#39;: &#39;{}&#39;}},</span>
<span class="go">     {&#39;eta&#39;: &#39;2010-06-07 09:07:53&#39;, &#39;priority&#39;: 0,</span>
<span class="go">      &#39;request&#39;: {</span>
<span class="go">        &#39;name&#39;: &#39;tasks.sleeptask&#39;,</span>
<span class="go">        &#39;id&#39;: &#39;49661b9a-aa22-4120-94b7-9ee8031d219d&#39;,</span>
<span class="go">        &#39;args&#39;: &#39;[2]&#39;,</span>
<span class="go">        &#39;kwargs&#39;: &#39;{}&#39;}}]}]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These are tasks with an eta/countdown argument, not periodic tasks.</p>
</div>
</div>
<div class="section" id="dump-of-reserved-tasks">
<span id="worker-inspect-reserved"></span><h3>Dump of reserved tasks<a class="headerlink" href="#dump-of-reserved-tasks" title="Permalink to this headline">¶</a></h3>
<p>Reserved tasks are tasks that has been received, but is still waiting to be
executed.</p>
<p>You can get a list of these using
<tt class="xref py py-meth docutils literal"><span class="pre">reserved()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">reserved</span><span class="p">()</span>
<span class="go">[{&#39;worker1.example.com&#39;:</span>
<span class="go">    [{&#39;name&#39;: &#39;tasks.sleeptask&#39;,</span>
<span class="go">      &#39;id&#39;: &#39;32666e9b-809c-41fa-8e93-5ae0c80afbbf&#39;,</span>
<span class="go">      &#39;args&#39;: &#39;(8,)&#39;,</span>
<span class="go">      &#39;kwargs&#39;: &#39;{}&#39;}]}]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="additional-commands">
<h2><a class="toc-backref" href="#id15">Additional Commands</a><a class="headerlink" href="#additional-commands" title="Permalink to this headline">¶</a></h2>
<div class="section" id="remote-shutdown">
<span id="std:control-shutdown"></span><h3>Remote shutdown<a class="headerlink" href="#remote-shutdown" title="Permalink to this headline">¶</a></h3>
<p>This command will gracefully shut down the worker remotely:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;shutdown&#39;</span><span class="p">)</span> <span class="c"># shutdown all workers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="s">&#39;shutdown, destination=&#39;</span><span class="n">worker1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="s">&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="ping">
<span id="std:control-ping"></span><h3>Ping<a class="headerlink" href="#ping" title="Permalink to this headline">¶</a></h3>
<p>This command requests a ping from alive workers.
The workers reply with the string &#8216;pong&#8217;, and that&#8217;s just about it.
It will use the default one second timeout for replies unless you specify
a custom timeout:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">ping</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[{&#39;worker1.example.com&#39;: &#39;pong&#39;},</span>
<span class="go"> {&#39;worker2.example.com&#39;: &#39;pong&#39;},</span>
<span class="go"> {&#39;worker3.example.com&#39;: &#39;pong&#39;}]</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/celery.app.control.html#celery.app.control.Control.ping" title="celery.app.control.Control.ping"><tt class="xref py py-meth docutils literal"><span class="pre">ping()</span></tt></a> also supports the <cite>destination</cite> argument,
so you can specify which workers to ping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ping</span><span class="p">([</span><span class="s">&#39;worker2.example.com&#39;</span><span class="p">,</span> <span class="s">&#39;worker3.example.com&#39;</span><span class="p">])</span>
<span class="go">[{&#39;worker2.example.com&#39;: &#39;pong&#39;},</span>
<span class="go"> {&#39;worker3.example.com&#39;: &#39;pong&#39;}]</span>
</pre></div>
</div>
<span class="target" id="worker-enable-events"></span><span class="target" id="std:control-enable_events"></span></div>
<div class="section" id="enable-disable-events">
<span id="std:control-disable_events"></span><h3>Enable/disable events<a class="headerlink" href="#enable-disable-events" title="Permalink to this headline">¶</a></h3>
<p>You can enable/disable events by using the <cite>enable_events</cite>,
<cite>disable_events</cite> commands.  This is useful to temporarily monitor
a worker using <strong class="program">celery events</strong>/<strong class="program">celerymon</strong>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">enable_events</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">celery</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">disable_events</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="writing-your-own-remote-control-commands">
<span id="worker-custom-control-commands"></span><h2><a class="toc-backref" href="#id16">Writing your own remote control commands</a><a class="headerlink" href="#writing-your-own-remote-control-commands" title="Permalink to this headline">¶</a></h2>
<p>Remote control commands are registered in the control panel and
they take a single argument: the current
<tt class="xref py py-class docutils literal"><span class="pre">ControlDispatch</span></tt> instance.
From there you have access to the active
<a class="reference internal" href="../internals/reference/celery.worker.consumer.html#celery.worker.consumer.Consumer" title="celery.worker.consumer.Consumer"><tt class="xref py py-class docutils literal"><span class="pre">Consumer</span></tt></a> if needed.</p>
<p>Here&#8217;s an example control command that restarts the broker connection:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">celery.worker.control</span> <span class="kn">import</span> <span class="n">Panel</span>

<span class="nd">@Panel.register</span>
<span class="k">def</span> <span class="nf">reset_connection</span><span class="p">(</span><span class="n">panel</span><span class="p">):</span>
    <span class="n">panel</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&#39;Connection reset by remote control.&#39;</span><span class="p">)</span>
    <span class="n">panel</span><span class="o">.</span><span class="n">consumer</span><span class="o">.</span><span class="n">reset_connection</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&#39;ok&#39;</span><span class="p">:</span> <span class="s">&#39;connection reset&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="../index.html">
  <img class="logo" src="http://cloud.github.com/downloads/celery/celery/celery_128.png" alt="Logo"/>
</a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="canvas.html"
                        title="previous chapter">Canvas: Designing Workflows</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="periodic-tasks.html"
                        title="next chapter">Periodic Tasks</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/userguide/workers.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="periodic-tasks.html" title="Periodic Tasks"
             >next</a> |</li>
        <li class="right" >
          <a href="canvas.html" title="Canvas: Designing Workflows"
             >previous</a> |</li>
        <li><a href="../index.html">Celery 3.1.0a1 documentation</a> &raquo;</li>
          <li><a href="index.html" >User Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2009-2012, Ask Solem &amp; Contributors.
    </div>
  </body>
</html>