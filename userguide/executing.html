<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Executing Tasks &mdash; Celery v0.8.0 (stable) documentation</title>
    <link rel="stylesheet" href="../static/adctheme.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.0 (stable)',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="Celery v0.8.0 (stable) documentation" href="../index.html" />
    <link rel="up" title="User Guide" href="index.html" />
    <link rel="next" title="Cookbook" href="../cookbook/index.html" />
    <link rel="prev" title="User Guide" href="index.html" /> 
  </head>
  <body>
<div id="docstitle">
	<p>Celery v0.8.0 (stable) documentation</p>
</div>
<div id="header">
	<div id="title"><h1>Executing Tasks</h1></div>
	<ul id="headerButtons">
		<li id="toc_button"><div class="headerButton"><a href="#">Table of Contents</a></div></li>
		<li id="page_buttons">
			<div class="headerButton"><a href="../genindex.html" title="General Index" accesskey="I">index</a></div>
			<div class="headerButton"><a href="../modindex.html" title="Global Module Index" accesskey="M">modules</a></div>
			<div class="headerButton"><a href="../cookbook/index.html" title="Cookbook" accesskey="N">next</a></div>
			<div class="headerButton"><a href="index.html" title="User Guide" accesskey="P">previous</a></div>
		</li>
	</ul>
</div>

<div id="sphinxsidebar">
  <div class="sphinxsidebarwrapper">
	<ul><li class="toctree-l1"><a href="../index.html">Main Page</a></li></ul>
	<ul class="current">
<li class="toctree-l1"><a class="reference external" href="../introduction.html">celery - Distributed Task Queue</a></li>
<li class="toctree-l1"><a class="reference external" href="../configuration.html">Configuration and defaults</a></li>
<li class="toctree-l1 current"><a class="reference external" href="index.html">User Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference external" href="">Executing Tasks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference external" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference external" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference external" href="../reference/index.html">Module API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="../internals/index.html">Internals</a></li>
<li class="toctree-l1"><a class="reference external" href="../changelog.html">Change history</a></li>
<li class="toctree-l1"><a class="reference external" href="../links.html">Interesting Links</a></li>
</ul>

      <h3>This Page</h3>
      <ul class="this-page-menu">
        <li><a href="../sources/userguide/executing.txt"
               rel="nofollow">Show Source</a></li>
      </ul>
    <div id="searchbox" style="display: none">
      
        <form class="search" action="../search.html" method="get">
			<div class="search-wrapper">
			<span class="search-left"></span>
			<input class="prettysearch" type="text" name="q" size="18" />
			<span class="search-right">&nbsp;</span>
			</div>
          <input type="submit" value="Search" class="searchbutton" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
        <p class="searchtip" style="font-size: 90%">
        Enter search terms or a module, class or function name.
        </p>
    </div>
    <script type="text/javascript">$('#searchbox').show(0);</script>
  </div>
</div>



    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="executing-tasks">
<h1>Executing Tasks<a class="headerlink" href="#executing-tasks" title="Permalink to this headline">¶</a></h1>
<p>Executing tasks is done with <tt class="docutils literal"><span class="pre">apply_async</span></tt>, and it&#8217;s shortcut <a href="#id1"><span class="problematic" id="id2">``</span></a>delay`.</p>
<p><tt class="docutils literal"><span class="pre">delay</span></tt> is simple and convenient, as it looks like calling a regular
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MyTask</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">kwarg1</span><span class="o">=</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="s">&quot;y&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The same thing using <tt class="docutils literal"><span class="pre">apply_async</span></tt> is written like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">AddTask</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;kwarg1&quot;</span><span class="p">:</span> <span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="s">&quot;kwarg2&quot;</span><span class="p">:</span> <span class="s">&quot;y&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>But <tt class="docutils literal"><span class="pre">delay</span></tt> doesn&#8217;t give you as much control as using <tt class="docutils literal"><span class="pre">apply_async</span></tt>.
With <tt class="docutils literal"><span class="pre">apply_async</span></tt> you can override the execution options available as attributes on
the <tt class="docutils literal"><span class="pre">Task</span></tt> class; <tt class="docutils literal"><span class="pre">routing_key</span></tt>, <tt class="docutils literal"><span class="pre">exchange</span></tt>, <tt class="docutils literal"><span class="pre">immediate</span></tt>, <tt class="docutils literal"><span class="pre">mandatory</span></tt>,
<tt class="docutils literal"><span class="pre">priority</span></tt>, and <tt class="docutils literal"><span class="pre">serializer</span></tt>.  In addition you can set a countdown or an eta, provide
a custom broker connection or change the broker connection timeout.</p>
<p>Let&#8217;s go over these in more detail. The following examples uses this simple
task, used to add two numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<div class="section" id="eta-and-countdown">
<h2>ETA and countdown<a class="headerlink" href="#eta-and-countdown" title="Permalink to this headline">¶</a></h2>
<p>The ETA (estimated time of arrival) lets you set a specific date and time for
when after, your task should execute. <tt class="docutils literal"><span class="pre">countdown</span></tt> is a shortcut to set this
by seconds into the future.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">AddTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">countdown</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>    <span class="c"># this takes at least 3 seconds to return</span>
<span class="go">20</span>
</pre></div>
</div>
<p>Note that your task is guaranteed to be executed at some time <em>after</em> the
specified date and time has passed, but not necessarily at that exact time.</p>
<p>While <tt class="docutils literal"><span class="pre">countdown</span></tt> is an integer, <tt class="docutils literal"><span class="pre">eta</span></tt> must be a <tt class="docutils literal"><span class="pre">datetime</span></tt> object,
specifying an exact date and time in the future. This is good if you already
have a <tt class="docutils literal"><span class="pre">datatime</span></tt> object and need to modify it with a <tt class="docutils literal"><span class="pre">timedelta</span></tt>, or when
specifing the time in seconds is not very readable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="k">def</span> <span class="nf">quickban</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ban user for 24 hours.&quot;&quot;&quot;</span>
    <span class="n">ban</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
    <span class="n">tomorrow</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">UnbanTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">username</span><span class="p">],</span> <span class="n">eta</span><span class="o">=</span><span class="n">tomorrow</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="serializer">
<h2>Serializer<a class="headerlink" href="#serializer" title="Permalink to this headline">¶</a></h2>
<p>The default serializer used is <tt class="xref docutils literal"><span class="pre">pickle</span></tt>, but you can change this default by
changing the <tt class="docutils literal"><span class="pre">CELERY_SERIALIZER</span></tt> configuration directive. There is built-in
support for using <tt class="docutils literal"><span class="pre">pickle</span></tt>, <tt class="docutils literal"><span class="pre">JSON</span></tt> and <tt class="docutils literal"><span class="pre">YAML</span></tt>, and you can add your own
custom serializers by registering them in the carrot serializer registry.</p>
<p>You don&#8217;t have to do any work on the worker receiving the task, the
serialization method is sent with the message so the worker knows how to
deserialize any task (of course, if you use a custom serializer, this must also be
registered in the worker.)</p>
<p>When sending a task the serializition method is taken from the following
places in order: The <tt class="docutils literal"><span class="pre">serializer</span></tt> argument to <tt class="docutils literal"><span class="pre">apply_async</span></tt>, the
Task&#8217;s <tt class="docutils literal"><span class="pre">serializer</span></tt> attribute, and finally the global default <tt class="docutils literal"><span class="pre">CELERY_SERIALIZER</span></tt>
configuration directive.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">AddTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">serializer</span><span class="o">=</span><span class="s">&quot;JSON&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="connections-and-connection-timeouts">
<h2>Connections and connection timeouts.<a class="headerlink" href="#connections-and-connection-timeouts" title="Permalink to this headline">¶</a></h2>
<p>Currently there is no support for broker connection pooling in celery, but
this might change in the future. This is something you need to be aware of
when sending more than one task at a time, as <tt class="docutils literal"><span class="pre">apply_async</span></tt> establishes and
closes a connection every time.</p>
<p>If you need to send more than one task at the same time, it&#8217;s a good idea to
establish the connectin yourself and pass it to <tt class="docutils literal"><span class="pre">apply_async</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">carrot.connection</span> <span class="kn">import</span> <span class="n">DjangoBrokerConnection</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">DjangoBrokerConnection</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">AddTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">print</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
</pre></div>
</div>
<p>In python 2.5 and above you can use the <tt class="docutils literal"><span class="pre">with</span></tt> statement with carrot
connections:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>
<span class="kn">from</span> <span class="nn">carrot.connection</span> <span class="kn">import</span> <span class="n">DjangoBrokerConnection</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">with</span> <span class="n">DjangoBrokerConnection</span><span class="p">()</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">AddTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<span class="k">print</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
</pre></div>
</div>
<p><em>NOTE</em> TaskSets already re-uses the same connection, but not if you need to
execute more than one TaskSet.</p>
<p>The connection timeout is the number of seconds to wait before we give up on
establishing the connection, you can set this with the <tt class="docutils literal"><span class="pre">connect_timeout</span></tt>
argument to <tt class="docutils literal"><span class="pre">apply_async</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">AddTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">connect_timeout</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>or if you handle your connection manually by using the connection objects
<tt class="docutils literal"><span class="pre">timeout</span></tt> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">connection</span> <span class="o">=</span> <span class="n">DjangoAMQPConnection</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="routing-options">
<h2>Routing options<a class="headerlink" href="#routing-options" title="Permalink to this headline">¶</a></h2>
<p>Celery uses the AMQP routing mechanisms to route tasks to different workers.
You can route tasks using the following entitites: exchange, queue and routing key.</p>
<p>Messages (tasks) are sent to exchanges, a queue binds to an exchange with a
routing key. Let&#8217;s look at an example:</p>
<p>Our application has a lot of tasks, some process video, others process images,
and some gathers collective intelligence about users. Some of these have
higher priority than others so we want to make sure the high priority tasks
get sent to powerful machines, while low priority tasks are sent to dedicated
machines that can handle these at their own pace, uninterrupted.</p>
<p>For the sake of example we have only one exchange called <tt class="docutils literal"><span class="pre">tasks</span></tt>.
There are different types of exchanges that matches the routing key in
different ways, the exchange types are:</p>
<ul>
<li><p class="first">direct</p>
<blockquote>
<p>Matches the routing key exactly.</p>
</blockquote>
</li>
<li><p class="first">topic</p>
<blockquote>
<p>In the topic exchange the routing key is made up of words separated by dots (<tt class="docutils literal"><span class="pre">.</span></tt>).
Words can be matched by the wildcars <tt class="docutils literal"><span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">#</span></tt>, where <tt class="docutils literal"><span class="pre">*</span></tt> matches one
exact word, and <tt class="docutils literal"><span class="pre">#</span></tt> matches one or many.</p>
<p>For example, <tt class="docutils literal"><span class="pre">*.stock.#</span></tt> matches the routing keys <tt class="docutils literal"><span class="pre">usd.stock</span></tt> and
<tt class="docutils literal"><span class="pre">euro.stock.db</span></tt> but not <tt class="docutils literal"><span class="pre">stock.nasdaq</span></tt>.</p>
</blockquote>
</li>
</ul>
<p>(there are also other exchange types, but these are not used by celery)</p>
<p>So, we create three queues, <tt class="docutils literal"><span class="pre">video</span></tt>, <tt class="docutils literal"><span class="pre">image</span></tt> and <tt class="docutils literal"><span class="pre">lowpri</span></tt> that binds to
our <tt class="docutils literal"><span class="pre">tasks</span></tt> exchange, for the queues we use the following binding keys:</p>
<div class="highlight-python"><pre>video: video.#
image: image.#
lowpri: misc.#</pre>
</div>
<p>Now we can send our tasks to different worker machines, by making the workers
listen to different queues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">CompressVideoTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">filename</span><span class="p">],</span>
<span class="gp">... </span>                              <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;video.compress&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ImageRotateTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">filename</span><span class="p">,</span> <span class="mi">360</span><span class="p">],</span>
<span class="go">                                routing_key=&quot;image.rotate&quot;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ImageCropTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">filename</span><span class="p">,</span> <span class="n">selection</span><span class="p">],</span>
<span class="go">                              routing_key=&quot;image.crop&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">UpdateReccomendationsTask</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;misc.recommend&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Later, if suddenly the image crop task is consuming a lot of resources,
we can bind some new workers to handle just the <tt class="docutils literal"><span class="pre">&quot;image.crop&quot;</span></tt> task,
by creating a new queue that binds to <tt class="docutils literal"><span class="pre">&quot;image.crop</span></tt>&#8220;.</p>
</div>
<div class="section" id="amqp-options">
<h2>AMQP options<a class="headerlink" href="#amqp-options" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>mandatory</li>
</ul>
<p>This sets the delivery to be mandatory. An exception will be raised
if there are no running workers able to take on the task.</p>
<ul class="simple">
<li>immediate</li>
</ul>
<p>Request immediate delivery. Will raise an exception
if the task cannot be routed to a worker immediately.</p>
<ul class="simple">
<li>priority</li>
</ul>
<p>A number between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">9</span></tt>, where <tt class="docutils literal"><span class="pre">0</span></tt> is the highest priority.
Note that RabbitMQ does not implement AMQP priorities, and maybe your broker
does not either, please consult your brokers documentation for more
information.</p>
</div>
</div>


          </div> 
        </div>
      </div>
    <div class="footer">
    <p>
      &copy; Copyright 2009, Ask Solem.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.3.
	</p>
    </div>
      <div class="clearer"></div>
    </div>
	<div id="breadcrumbs">
		<a href="index.html" accesskey="U">User Guide</a><img src="triangle_closed.png" alt="Right arrow">
		<a href="../index.html">Celery v0.8.0 (stable) documentation</a>
		</ul>
	</div>
  </body>
</html>